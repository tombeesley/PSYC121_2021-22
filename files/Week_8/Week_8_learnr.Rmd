---
title: 'PSYC121: Week 8 Lab'
output:
  learnr::tutorial:
    progressive: yes
    allow_skip: yes
runtime: shiny_prerendered
resource_files:
- tidy_data.RData
- Week_7_learnr.Rmd
- Week_7_learnr.Rmd
- tidy_data.RData
- Week_8_learnr.Rmd
- tidy_data.RData
- Week_8_learnr.Rmd
- tidy_data.RData
---

```{r setup, include=FALSE, exercise.startover = TRUE}
library(tidyverse)
library(learnr)

load("tidy_data.RData")

data <- data %>%
  select(home_location, maths_skills, countries_visited) %>%
  mutate(maths_skills = case_when(str_detect(maths_skills, "Well above") ~ "above",
                                  str_detect(maths_skills, "little above") ~ "above",
                                  maths_skills == "Average" ~ "average",
                                  str_detect(maths_skills, "little below") ~ "below",
                                  str_detect(maths_skills, "Well below") ~ "below")) %>% 
  filter(countries_visited > 0) %>% 
  filter(home_location %in% c("UK", "Asia", "Europe (not UK)"))

knitr::opts_chunk$set(echo = FALSE)
```

## Visualise the data

For this week's online tutorial we have loaded in a new selection of the data (which we've stored as `data`) from the PSYC121 questionnaire. 

Let's take a look at the data by drawing a new type of graph called a "dotplot". The code below will map the variable *countries_visited* to the y-axis, and will map *maths_skills* variable on the x-axis. You'll see there are a couple of additional parameters, and each one has a comment (use # to add comments to your code!) next to it to explain the purpose.

```{r dotplot, exercise=TRUE}

data %>% 
  ggplot() +
  geom_dotplot(aes(y = countries_visited, x = maths_skills),
               binaxis = "y", # dots grouped according to variable mapped to y
               stackdir = "center") # centre alignment of the dots

```

We can also look at the data using another type of distribution plot. This one is called a "violin" plot:

```{r violin, exercise=TRUE}

data %>% 
  ggplot() +
  geom_violin(aes(y = countries_visited, x = maths_skills)) 

```

This is another way to present distributional data, and gives a sense of the shape of the distribution with its curves. OK, that's nice. But maybe we want to look at both of these types of plots together. Maybe we want a violin plot, but we also want the dotplot over the top. And why not?! We have said before, `ggplot` is very flexible and we can make almost any plot we want:

```{r violin_boxplot, exercise=TRUE}

data %>% 
  ggplot() +
  geom_violin(aes(y = countries_visited, x = maths_skills)) +
  geom_dotplot(aes(y = countries_visited, x = maths_skills),
               binaxis = "y", # dots grouped according to variable mapped to y
               stackdir = "center") # centre alignment of the dots

```

This works just fine, but (as often is the case) there's a better way. We're mapping the same variables to the same features in two graphs (once for the violin plot and once for the dotplot). This is a bit inefficient and of course there's a better way...

### Global aes()

What we need to do is use the `aes()` command within the first `ggplot()` command itself. Add the mappings for y and x to the `ggplot(aes())` command below. You can use a hint if you get really stuck.

```{r global_aes, exercise=TRUE}

data %>% 
  ggplot(aes()) + 
  geom_violin(aes()) +
  geom_dotplot(aes(),
               binaxis = "y", # dots grouped according to variable mapped to y
               stackdir = "center") # centre alignment of the dots

```
```{r global_aes-hint-1}

data %>% 
  ggplot(aes(y = , x = )) + 
  geom_violin(aes()) +
  geom_dotplot(aes(),
               binaxis = "y", # dots grouped according to variable mapped to y
               stackdir = "center") # centre alignment of the dots

```
```{r global_aes-hint-2}

data %>% 
  ggplot(aes(y = , x = )) + 
  geom_violin(aes(fill = )) + 
  geom_dotplot(aes(),
               binaxis = "y", # dots grouped according to variable mapped to y
               stackdir = "center") # centre alignment of the dots

```
```{r global_aes-solution}

data %>% 
  ggplot(aes(y = countries_visited, x = maths_skills)) + 
  geom_violin(aes(fill = maths_skills)) +
  geom_dotplot(aes(),
               binaxis = "y", # dots grouped according to variable mapped to y
               stackdir = "center") # centre alignment of the dots

```

Now, try adding a new mapping only the violin plot: add a mapping between *maths_skills* and *fill*. Use the hints and solution if you get really stuck. Make sure you take in this graph and undestand what the code is doing. Two of the mappings (*y* and *x*) are applied **globally** to both the `geom_violin` and the `geom_dotplot`, while one of the mapping (*fill*) is applied only to the `geom_violin`.

## Calculating means and standard errors

In previous weeks you have used the `group_by()` and `summarise()` commands to calculate some mean values within your data, as a function of other variables. For example, we can do that here for the mean countries traveled by the home location of the respondent:

```{r group_mean_sd, exercise = TRUE}

data %>% 
  group_by(home_location) %>% 
  summarise(mean_travel = mean(countries_visited))


```

In the next code box, add in a second line to the summarise command that calculates the standard deviation (`sd()`) of the data. If you get really stuck here, there's a solution.

```{r group_sd, exercise = TRUE}

data %>% 
  group_by(home_location) %>% 
  summarise(mean_travel = mean(countries_visited),
            sd_travel = ) # add the missing code here


```

```{r group_sd-solution}

data %>% 
  group_by(home_location) %>% 
  summarise(mean_travel = mean(countries_visited),
            sd_travel = sd(countries_visited))


```

### From SDs to SEs

We've also seen in the lectures that when we make inferences about differences between means, then it is important to estimate the variability in the sampling of the mean. We call this the **standard error**, and when we plot means it is very common to also plot the standard error of the mean (**SEM**). 

SE is calculated as the standard deviation divided by the square root of N. Here is an example of calculating this in the summarise command: 

```{r se_example, exercise = TRUE}

data %>% 
  group_by(home_location) %>% 
  summarise(mean_travel = mean(countries_visited),
            se_travel = sd(countries_visited)/sqrt(n())) 

# n() is simply how many rows of data there are for this selection


```

### EXTRA - Pipe it to ggplot()

The results of this summary can now be graphed, by sending the results (`%>%`) into the ggplot command. Read through the code below carefully, then click Run to plot these means and standard errors in a graph:

```{r plot_se, exercise = TRUE}

data %>% 
  group_by(home_location) %>% 
  summarise(mean_travel = mean(countries_visited),
            se_travel = sd(countries_visited)/sqrt(n())) %>% # This line and those above are the same as the previous code chunk
  ggplot(aes(y = mean_travel, x = home_location)) + # Adding a ggplot (graph)
  geom_col() + # columns
  geom_errorbar(aes(ymin = mean_travel - se_travel, # the minimum value for the error bar
                    ymax = mean_travel + se_travel), # the maximum value for the error bar
                width = .2) # how wide we want the error bar - feel free to change this.


```

```{r plot_se-solution}

data %>% 
  group_by(home_location) %>% 
  summarise(mean_travel = mean(countries_visited),
            se_travel = sd(countries_visited)/sqrt(n())) %>% 
  ggplot(aes(y = mean_travel, x = home_location, colour = home_location, fill = home_location)) +
  geom_col() +
  geom_errorbar(aes(ymin = mean_travel - se_travel, # the minimum value for the error bar
                    ymax = mean_travel + se_travel), # the maximum value for the error bar
                width = .2) # how wide we want the error bar - feel free to change this.


```

Note how we have placed the y and x mappings into the `ggplot(aes())` here, so that they are shared by the columns (`geom_col`) and the error bars (`geom_errorbar`). 

The graph is very grey and boring! Within `ggplot()`, try to mapping the *home_location* variable to *fill* as well as *x*. Now try mapping it to *colour* instead of, or in addition to, *fill*. Note how the *fill* feature is applied to only the columns, but the *colour* feature applies to both the columns and the error bars. There is a solution available if you get stuck.

There's lots of things you can change in graphs. Try playing around with some of the fixed settings (i.e., outside of `aes()`). Here are some suggestions. What can you come up with?

- geom_col(alpha = .3, fill = "orange")
- geom_col(linetype = 4, fill = "white")
- geom_col(linetype = 6, size = 2)
- try the linetype, alpha and size settings in the `geom_errorbar()` geom. Put them outside of `aes()`


### End of tutorial

This is now the end of the online tutorial `ggplot`. Please return to the tasks in the lab worksheet.




